# 백엔드 프로젝트 구조 가이드

## 📁 디렉토리 구조

```
server/
├── config/           # 설정 파일들
│   ├── database.js   # MySQL 연결 설정
│   ├── auth.js       # JWT 토큰 설정
│   └── schema.sql    # 데이터베이스 스키마
├── controllers/      # 비즈니스 로직 처리
├── middleware/       # 미들웨어 함수들
├── models/          # 데이터베이스 모델
├── routes/          # API 라우트 정의
├── scripts/         # 스크립트 파일들
│   └── initDB.js    # 데이터베이스 초기화
├── utils/           # 유틸리티 함수들
├── .env             # 환경변수
├── server.js        # 메인 서버 파일
└── package.json     # 프로젝트 의존성
```

## 🔧 주요 컴포넌트

### 1. Config (설정)

- **database.js**: MySQL 연결 설정 및 풀 관리 (diggiding 데이터베이스 사용)
- **auth.js**: JWT 토큰 생성/검증 설정
- **schema.sql**: 데이터베이스 테이블 스키마 정의

### 2. Models (모델)

- **User.js**: 사용자 데이터베이스 모델
  - 회원가입, 로그인, 프로필 관리
  - 비밀번호 해싱 (bcrypt)
  - 스키마: id, username, email, password_hash, created_at

### 3. Controllers (컨트롤러)

- **authController.js**: 인증 관련 로직
  - 회원가입, 로그인, 현재 사용자 정보
- **userController.js**: 사용자 관련 로직
  - 프로필 업데이트, 비밀번호 변경

### 4. Middleware (미들웨어)

- **auth.js**: JWT 토큰 인증
- **validation.js**: 입력값 검증

### 5. Routes (라우트)

- **auth.js**: 인증 관련 API 엔드포인트
- **users.js**: 사용자 관련 API 엔드포인트
- **index.js**: 라우트 통합 관리

### 6. Utils (유틸리티)

- **response.js**: 일관된 API 응답 포맷
- **helpers.js**: 공통 유틸리티 함수들

### 7. Scripts (스크립트)

- **initDB.js**: 데이터베이스 초기화 스크립트
  - 테이블 생성
  - 관리자 계정 생성 (admin / admin123!)
  - 더미 사용자 데이터 생성

## 🛠 환경 설정

`.env` 파일에 다음 변수들을 설정하세요:

```env
# 서버 설정
PORT=5000
NODE_ENV=development

# 데이터베이스 설정
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=diggiding

# JWT 설정
JWT_SECRET=your-secret-key-here
JWT_EXPIRES_IN=24h
```

## 📊 데이터베이스 설정

### 데이터베이스 초기화

MySQL 서버 시작 후 다음 명령어를 실행하여 데이터베이스를 초기화하세요:

```bash
node scripts/initDB.js
```

이 스크립트는 다음 작업을 수행합니다:

1. `diggiding` 데이터베이스 생성 (없는 경우)
2. users 테이블 생성
3. 관리자 계정 생성 (username: admin, password: 1234)
4. 더미 사용자 데이터 생성

### users 테이블 스키마

```sql
CREATE TABLE IF NOT EXISTS users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 생성되는 계정들

- **관리자 계정**:

  - username: `admin`
  - email: `admin@example.com`
  - password: `1234`

- **더미 사용자들**:
  - test1, test2, test3, test4, test5
  - password: `test1234`

## 🔗 API 엔드포인트

### 기본 정보

- **Base URL**: `http://localhost:5000`
- **Content-Type**: `application/json`
- **인증 방식**: JWT Bearer Token

### 인증 API (/api/auth)

#### 1. 회원가입

```http
POST /api/auth/register
```

**Request Body:**
```json
{
  "username": "testuser",
  "email": "test@example.com",
  "password": "password123"
}
```

**Success Response (201):**
```json
{
  "success": true,
  "message": "User registered successfully",
  "data": {
    "user": {
      "id": 1,
      "username": "testuser",
      "email": "test@example.com",
      "created_at": "2024-01-01T00:00:00.000Z"
    },
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }
}
```

**Error Response (400):**
```json
{
  "success": false,
  "message": "Email already exists"
}
```

#### 2. 로그인

```http
POST /api/auth/login
```

**Request Body:**
```json
{
  "email": "test@example.com",
  "password": "password123"
}
```

**Success Response (200):**
```json
{
  "success": true,
  "message": "Login successful",
  "data": {
    "user": {
      "id": 1,
      "username": "testuser",
      "email": "test@example.com",
      "created_at": "2024-01-01T00:00:00.000Z"
    },
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }
}
```

**Error Response (401):**
```json
{
  "success": false,
  "message": "Invalid email or password"
}
```

#### 3. 현재 사용자 정보 조회

```http
GET /api/auth/me
```

**Headers:**
```http
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Success Response (200):**
```json
{
  "success": true,
  "message": "User data retrieved",
  "data": {
    "id": 1,
    "username": "testuser",
    "email": "test@example.com",
    "created_at": "2024-01-01T00:00:00.000Z"
  }
}
```

### 기타 API

#### 헬스 체크

```http
GET /api/health
```

**Success Response (200):**
```json
{
  "success": true,
  "message": "API is running",
  "data": {
    "status": "healthy",
    "timestamp": "2024-01-01T00:00:00.000Z"
  }
}
```

### 프론트엔드 구현 가이드

#### 1. 회원가입 구현 예시

```javascript
// 회원가입 함수
const register = async (userData) => {
  try {
    const response = await fetch('http://localhost:5000/api/auth/register', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(userData)
    });
    
    const data = await response.json();
    
    if (data.success) {
      // 토큰을 localStorage에 저장
      localStorage.setItem('token', data.data.token);
      // 사용자 정보 저장
      localStorage.setItem('user', JSON.stringify(data.data.user));
      return data;
    } else {
      throw new Error(data.message);
    }
  } catch (error) {
    console.error('Registration error:', error);
    throw error;
  }
};
```

#### 2. 로그인 구현 예시

```javascript
// 로그인 함수
const login = async (credentials) => {
  try {
    const response = await fetch('http://localhost:5000/api/auth/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(credentials)
    });
    
    const data = await response.json();
    
    if (data.success) {
      // 토큰을 localStorage에 저장
      localStorage.setItem('token', data.data.token);
      // 사용자 정보 저장
      localStorage.setItem('user', JSON.stringify(data.data.user));
      return data;
    } else {
      throw new Error(data.message);
    }
  } catch (error) {
    console.error('Login error:', error);
    throw error;
  }
};
```

#### 3. 인증된 요청 보내기

```javascript
// 인증이 필요한 API 호출
const fetchUserData = async () => {
  try {
    const token = localStorage.getItem('token');
    
    const response = await fetch('http://localhost:5000/api/auth/me', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      }
    });
    
    const data = await response.json();
    
    if (data.success) {
      return data.data;
    } else {
      throw new Error(data.message);
    }
  } catch (error) {
    console.error('Fetch user data error:', error);
    throw error;
  }
};
```

#### 4. 로그아웃 구현

```javascript
// 로그아웃 함수
const logout = () => {
  localStorage.removeItem('token');
  localStorage.removeItem('user');
  // 로그인 페이지로 리다이렉트
  window.location.href = '/login';
};
```

### 에러 처리

모든 API 응답은 다음과 같은 형식을 따릅니다:

**성공 응답:**
```json
{
  "success": true,
  "message": "작업 완료 메시지",
  "data": { /* 응답 데이터 */ }
}
```

**에러 응답:**
```json
{
  "success": false,
  "message": "에러 메시지"
}
```

#### 주요 HTTP 상태 코드

- `200`: 성공
- `201`: 생성 성공
- `400`: 잘못된 요청
- `401`: 인증 실패
- `404`: 리소스 없음
- `500`: 서버 에러

## 📋 서버 코드 구조 상세 설명

### 1. 데이터베이스 연결 (config/database.js)

이 파일은 MySQL 데이터베이스 연결을 관리합니다:

```javascript
// 연결 풀 생성 - 여러 동시 연결을 효율적으로 관리
const pool = mysql.createPool({
  host: 'localhost',
  user: 'root', 
  password: '',
  database: 'diggiding',
  connectionLimit: 10  // 최대 10개의 동시 연결
});
```

**주요 기능:**
- 연결 풀을 사용하여 성능 최적화
- 환경변수를 통한 설정 관리
- 연결 테스트 함수 제공

### 2. 사용자 모델 (models/User.js)

데이터베이스의 users 테이블과 상호작용하는 모델:

```javascript
class User {
  // 사용자 생성 시 자동으로 비밀번호 해싱
  static async create(userData) {
    const hashedPassword = await bcrypt.hash(password, 12);
    // 데이터베이스에 저장
  }
  
  // 로그인 시 비밀번호 검증
  async comparePassword(password) {
    return await bcrypt.compare(password, this.password_hash);
  }
}
```

**주요 기능:**
- bcrypt를 사용한 안전한 비밀번호 해싱
- 이메일/ID로 사용자 찾기
- 비밀번호 제외한 안전한 데이터 반환

### 3. 인증 컨트롤러 (controllers/authController.js)

인증 관련 비즈니스 로직을 처리:

```javascript
// 회원가입: 중복 체크 → 사용자 생성 → JWT 토큰 발급
const register = async (req, res) => {
  const existingUser = await User.findByEmail(email);
  if (existingUser) {
    return sendError(res, 'Email already exists', 400);
  }
  // 새 사용자 생성 및 토큰 발급
};

// 로그인: 사용자 확인 → 비밀번호 검증 → JWT 토큰 발급
const login = async (req, res) => {
  const user = await User.findByEmail(email);
  const isValid = await user.comparePassword(password);
  // 검증 후 토큰 발급
};
```

### 4. 응답 유틸리티 (utils/response.js)

일관된 API 응답 형식을 제공:

```javascript
// 성공 응답
const sendSuccess = (res, data, message, statusCode = 200) => {
  res.status(statusCode).json({
    success: true,
    message,
    data
  });
};

// 에러 응답
const sendError = (res, message, statusCode = 500) => {
  res.status(statusCode).json({
    success: false,
    message
  });
};
```

### 5. JWT 인증 설정 (config/auth.js)

JWT 토큰 생성 및 검증을 처리:

```javascript
// 토큰 생성
const generateToken = (payload) => {
  return jwt.sign(payload, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || '24h'
  });
};

// 토큰 검증
const verifyToken = (token) => {
  return jwt.verify(token, process.env.JWT_SECRET);
};
```

### 6. 인증 미들웨어 (middleware/auth.js)

보호된 라우트에 대한 인증 체크:

```javascript
const authenticate = async (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return sendError(res, 'No token provided', 401);
  }
  
  try {
    const decoded = verifyToken(token);
    req.user = decoded;  // 요청 객체에 사용자 정보 추가
    next();
  } catch (error) {
    return sendError(res, 'Invalid token', 401);
  }
};
```

### 7. 라우트 구조 (routes/)

API 엔드포인트를 정의:

```javascript
// routes/auth.js
router.post('/register', register);
router.post('/login', login);
router.get('/me', authenticate, getMe);  // 인증 미들웨어 적용

// routes/index.js
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
```

### 8. 메인 서버 (server.js)

Express 서버 설정 및 미들웨어 구성:

```javascript
const app = express();

// 미들웨어 설정
app.use(cors());
app.use(helmet());
app.use(express.json());

// 라우트 등록
app.use('/api', routes);

// 데이터베이스 연결 테스트
testConnection();

// 서버 시작
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
```

## 🔧 개발 워크플로우

### 1. 프로젝트 시작
```bash
# 의존성 설치
npm install

# 환경변수 설정
cp .env.example .env

# 데이터베이스 초기화
node scripts/initDB.js

# 개발 서버 시작
npm run dev
```

### 2. 새로운 API 추가 시 절차

1. **모델 수정** (models/)
   - 데이터베이스 스키마 변경
   - 새로운 쿼리 메소드 추가

2. **컨트롤러 작성** (controllers/)
   - 비즈니스 로직 구현
   - 에러 처리 로직 추가

3. **라우트 등록** (routes/)
   - 새로운 엔드포인트 정의
   - 미들웨어 적용

4. **문서 업데이트**
   - API 명세 추가
   - 사용 예시 작성

### 3. 보안 고려사항

- 비밀번호는 절대 평문으로 저장하지 않음
- JWT 토큰에 민감한 정보 포함 금지
- 입력값 검증 및 SQL 인젝션 방지
- CORS 설정을 통한 요청 제한
- Helmet을 사용한 보안 헤더 설정
